//  Recent authors, Erin Coughlan and Vivian Wehner//       Seed canny code by Redjan F. Shabani// Might need to redirect things// search for opencv.pc// then export PKG_CONFIG_PATH=whereEverYouFound it// To run, g++ canny.c `pkg-config --cflags --libs opencv`// then ./a.out filename.jpg //// for our test files, // ./a.out Neural/CS152FinalProject/Code/all_images/an2i_straight_happy_open.pgm // Differences between cvMat, Mat and IpImage// C++ Mat// old intel is IpImage#include <cv.h>#include <stdio.h>#include <stdlib.h>#include <opencv/cxcore.h>#include <iostream>#include <string>#include <opencv/highgui.h>#define CV_IMWRITE_PXM_BINARY 32using namespace cv;using namespace std;char* get_filename_from_path(char* filepath, int MAX_STR_LENGTH );int main(int argc,char** argv){  Mat image;  int MAX_STR_LENGTH = strlen(argv[1]);  // Load a new image  char* fileNameC = argv[1];  string fileNameS = argv[1];    image = imread(argv[1], CV_LOAD_IMAGE_COLOR);  // Check for invalid input  if(! image.data ){    cout <<  "Could not open or find the image" << std::endl ;    return -1;  }  // Make a new window and display it  namedWindow("CannyEdges", CV_WINDOW_AUTOSIZE);  IplImage* frameRGB=cvCloneImage(&(IplImage)image);  IplImage* frameG=cvCreateImage(cvGetSize(frameRGB),IPL_DEPTH_8U,0);  cvConvertImage(frameRGB,frameG,0);   // How big is it?   CvSize sz=cvGetSize(frameRGB);  sz.width=sz.width;  sz.height=sz.height;              // Another Frame!   IplImage* frameRG=cvCreateImage(sz,IPL_DEPTH_8U,0);  cvResize(frameG, frameRG,CV_INTER_LINEAR);              // Another Frame, the same size  IplImage* framec=cvCreateImage(sz,IPL_DEPTH_8U,0);                cvCanny(frameRG, framec, 40, 90, 3);  cvShowImage("Original View",frameRGB);  cvShowImage("Canny Edges",framec);    CvMat stub, *imgMat;  imgMat = cvGetMat(framec, &stub, 0 , 0);  // Output as a bmp  //Mat imgMat(framec);  //if(!cvSaveImage("outFileName.bmp",framec))  //if(!imwrite("outFileName.pbm",imgMat))  //  printf("Could not save: %s\n","outFileName");  char* result = get_filename_from_path(fileNameC, MAX_STR_LENGTH);  int x;  int newLen = strlen(result);  int newStart = MAX_STR_LENGTH - newLen;  char tmp[newLen];  for(x=0; x < newLen; x++){    if ( x > newLen - 4){      if(x == newLen - 3)	tmp[x] = 'x';      if(x == newLen - 2)	tmp[x] = 'm';      if (x == newLen - 1)	tmp[x] = 'l';    }    else{      if(fileNameC[newStart] == '_')	tmp[x] = '0';      else	tmp[x] = fileNameC[newStart];      newStart += 1;    }  }    printf("with last char removed: %s\n",tmp);  CvFileStorage* fs = cvOpenFileStorage(tmp, 0, CV_STORAGE_WRITE);  cvSetIdentity (imgMat);  cvWrite(fs, "bob", imgMat, cvAttrList(0,0));  cvReleaseFileStorage( &fs);  cvReleaseMat( &imgMat);  // Will break on any key being hit  cvWaitKey(0);  return 0;}char* get_filename_from_path(char* filepath, int MAX_STR_LENGTH ){  char *filename = (char*)calloc(1, sizeof(MAX_STR_LENGTH));  filename = (strrchr(filepath, '/')) + 1;  printf(" found filename: %s\n", filename);  return filename;}